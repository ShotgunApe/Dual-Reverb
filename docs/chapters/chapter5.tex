%!TEX root = ../username.tex
\chapter{The Software}
\hspace*{-0.15cm}To bring everything together, this chapter will cover how the application was created using JUCE. It will begin with a description of the data structures that were used before describing their implementation. Then, the process of creating the user interface will be described. Finally, it will end with how the software runs under several different host applications.
\section{Data Structures and Implementation}
Both Comb Filters and Allpass Filters use a queue ADT for their implementation. However, they rely on an implementation that uses a \textit{circular array} so that audio data can be continuously fed into the application. In other words, an array with modular arithmetic is used so that audio data can be continuously queued. This ignores the usual problem that come from circular arrays; that current lengths can be ambiguous for the same \textit{front} and \textit{back} pointer \cite{carrano2016data}. For the purposes that this data structure is being used for for, all that matters is that data can be continuously processed in the system and overwritten when new data comes in.

To implement a Comb Filter, one can imagine an array of floats representing a buffer of data to be processed. A subsection of this buffer will be specified as the signal to repeat of an arbitrary length. This is the delay buffer. To match the behavior expected of a Comb Filter in code, one can imagine filling a temporary buffer with data. One can then read this data back to the original buffer once it has been processed (i.e., the write pointer of the circular array has moved past the data read thus far). JUCE provides a datatype \verb|AudioBuffer<Type>| that allows the programmer to copy data from one buffer to the next (or rather, the primary buffer to output and a buffer containing the temporary delayed signal) - however, it is up to the programmer to implement the circular behavior themselves so that undefined behavior does not occur.
\lstset{language =[ANSI]C++}
\lstset{backgroundcolor=\color{white},rulecolor=\color{black}}
\lstset{linewidth=.95\textwidth,breaklines=true}
\lstset{commentstyle=\textit,stringstyle=\upshape,showspaces=false}
\lstset{frame = single}
\lstset{numbers=left,numberstyle=\tiny,basicstyle=\small}
\lstset{commentstyle=\normalfont\itshape,breakautoindent=true}
\lstset{abovecaptionskip=1.2\baselineskip,xleftmargin=30pt}
\lstset{framesep=6pt}
\begin{singlespace}
\lstinputlisting[caption=The high level code of a Comb Filter., label=motion]{source/pseudo1.txt}
\end{singlespace} \hfill \break
\hspace*{0.6cm}This circular behavior can be defined as a custom class \verb|DelayLine|, whose members are defined in Listing A.1. As part of this class, to implement \verb|fillBuffer()|, JUCE provides functions under the \verb|juce_audio_basics/juce_audio_basics.h| header. These include the functions \verb|getNumSamples()|, \verb|copyFrom()|, and \verb|getWritePointer()|. Essentially, the function \verb|fillBuffer()| first checks the size of the delay buffer. Upon doing so, if the write position (the \textit{front} pointer of the circular array) is within the bounds of the delay buffer, then the audio data can simply be copied from the delay buffer to the buffer via the \verb|copyFrom()| function. If not, care is taken to calculate the correct length of the delay buffer and how many samples are present between the \textit{head} and the \textit{back} pointer of the delay line. The \verb|copyFrom()| function can then be used in a similar manner.

This takes care of filling the buffer with the data sent through the delay line (Figure 4.3, filling the buffer with the delay of time \textit{T}). However, \verb|readFromBuffer()| must read this data to be sent back through the filter as an input with some gain \text{g}. To calculate the gain parameter, the naive approach would be to set the variable to some constant. However, this does not work as the length of the decay would be different for each delay time \textit{T}. To ensure that each delay line does not have different lengths, \textit{g} be calculated as a function with respect to the length of time that the programmer wishes to have the Comb Filter last. This can be done with the following equation:

\begin{center}
\scalebox{1.3}{
$
g = 10^{\frac{-3DT_s}{RT_{60}}}
$
}
\end{center}

where $D$ is the delay line length in seconds, $T_s$ the sample rate, and $RT_{60}$ the reverberation time in seconds  \cite{pirkle2019designing}. However, one can simplify this further as the sample rate conversion is simply an intermediary to convert seconds to discrete buffers. If working purely with lengths of buffers, this simplifies to:

\begin{center}
\scalebox{1.3}{
$
g = 10^{\frac{-3D_b}{RT_b}}
$
}
\end{center}

where $D_b$ is the delay line length in buffers and $RT_b$ is likewise the $RT_{60}$ time in buffers. This translates to the following code:

\begin{singlespace}
\lstinputlisting[caption=Code to calculate $g$ within a delay line., label=motion]{source/pseudo2.txt}
\end{singlespace} \hfill \break
\hspace*{0.6cm}It is worth reiterating, the gain \textit{g} applied during the \verb|readFromBuffer()| step \textit{must} be calculated for each different delay length. For multiple delays, if a constant \textit{g} is applied for each different delay length, the comb filters will finish decaying at different points in time. This calculation avoids this. The function separates this approach from being just a number of delays played at once - they all contain the same $RT_{60}$ time, despite being of different delay lengths with each repeated signal.

With the gain parameter handled, the \verb|readFromBuffer()| function can be implemented by adding the delayed signal back to the input buffer with the calculated gain applied. This is different from the copy step as the signal is not being replaced - the new signal must be the sum of the next incoming signal with the (now delayed) previous. JUCE contains the function \verb|addFromWithRamp()| that accomplishes this.

\begin{singlespace}
\lstinputlisting[caption=Code to take the sum of two signals., label=motion]{source/pseudo3.txt}
\end{singlespace} \hfill \break
\hspace*{0.6cm}Lastly, it is the responsibility of the programmer to update the \textit{head} pointer to ensure that the circular buffer stays within its intended space in memory and prevents undefined behavior from occuring.

\begin{singlespace}
\lstinputlisting[caption=Code to implement circular behavior in an array., label=motion]{source/pseudo4.txt}
\end{singlespace} \hfill \break
\hspace*{0.6cm}Placing each component in context, these functions work together by being placed within a greater \verb|processBlock()| function that takes a buffer, applies some processing, and sends it back to the DAW.

\section{User Interface}

\section{Compatibility with DAWs}
